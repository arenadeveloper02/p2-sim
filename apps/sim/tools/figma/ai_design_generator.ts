import type { ToolConfig } from '@/tools/types'

export interface AIDesignGeneratorParams {
  designPrompt: string
  designType: 'landing_page' | 'component' | 'wireframe' | 'generic'
  brandGuidelines?: File
  wireframes?: File
  fileName: string
  fileDescription?: string
  autoGenerateDesign: boolean
  autoExport: boolean
  exportFormat: 'PNG' | 'JPG' | 'SVG' | 'PDF'
  projectId?: string
  teamId?: string
  includeCodeOutput: boolean
  targetAudience?: string
  businessGoals?: string
}

export interface AIDesignGeneratorResponse {
  success: boolean
  output: {
    content: string
    metadata: {
      fileCreation?: {
        success: boolean
        fileKey: string
        fileName: string
        fileUrl: string
        projectId?: string
        teamId?: string
      }
      pluginInvocation: {
        status: 'success' | 'error'
        message: string
        generatedFrameId?: string
        elementCount?: number
        autoGenerated: boolean
        exportData?: {
          format: string
          data: string
          size: number
          metadata: any
          timestamp: string
        }
      }
      aiContentGeneration: {
        prompt: string
        designType: string
        generatedContent: string
        contentLength: number
        contentType: string
        generationMethod: string
      }
      designSpecifications: {
        layout: string
        components: string[]
        colors: string[]
        typography: string[]
        responsive: boolean
      }
      codeOutput?: {
        html: string
        css: string
        react?: string
        figmaPrompt: string
      }
      nextSteps: string[]
    }
  }
}

export const aiDesignGeneratorTool: ToolConfig<
  AIDesignGeneratorParams,
  AIDesignGeneratorResponse
> = {
  id: 'ai_design_generator',
  name: 'AI-Powered Figma Design Generator',
  description:
    'Generate Figma designs automatically using AI-generated content from workflows. Creates designs without human intervention.',
  version: '1.0.0',
  params: {
    designPrompt: {
      type: 'string',
      description: 'Description of the design to create',
      required: true,
      visibility: 'user-or-llm',
    },
    designType: {
      type: 'string',
      description: 'Type of design to generate',
      required: true,
      visibility: 'user-or-llm',
    },
    brandGuidelines: {
      type: 'file',
      description: 'Brand guidelines file to inform the design',
      required: false,
      visibility: 'user-or-llm',
    },
    wireframes: {
      type: 'file',
      description: 'Wireframe or sketch file to convert to UI design',
      required: false,
      visibility: 'user-or-llm',
    },
    fileName: {
      type: 'string',
      description: 'Name for the new Figma file to be created',
      required: true,
      visibility: 'user-or-llm',
    },
    fileDescription: {
      type: 'string',
      description: 'Description for the Figma file',
      required: false,
      visibility: 'user-or-llm',
    },
    autoGenerateDesign: {
      type: 'boolean',
      description: 'Automatically generate design without human intervention',
      required: false,
      visibility: 'user-or-llm',
    },
    autoExport: {
      type: 'boolean',
      description: 'Automatically export the generated design',
      required: false,
      visibility: 'user-or-llm',
    },
    exportFormat: {
      type: 'string',
      description: 'Format for exporting the design',
      required: false,
      visibility: 'user-or-llm',
    },
    projectId: {
      type: 'string',
      description: 'Figma project ID where the file will be created',
      required: false,
      visibility: 'user-or-llm',
    },
    teamId: {
      type: 'string',
      description: 'Figma team ID',
      required: false,
      visibility: 'user-or-llm',
    },
    includeCodeOutput: {
      type: 'boolean',
      description: 'Generate code output along with design',
      required: false,
      visibility: 'user-or-llm',
    },
    targetAudience: {
      type: 'string',
      description: 'Target audience for the design',
      required: false,
      visibility: 'user-or-llm',
    },
    businessGoals: {
      type: 'string',
      description: 'Business goals the design should achieve',
      required: false,
      visibility: 'user-or-llm',
    },
  },
  request: {
    url: 'https://api.figma.com/v1/me',
    method: 'GET',
    headers: () => ({
      'X-Figma-Token': process.env.FIGMA_API_KEY || '',
    }),
  },
  transformResponse: async (response, params) => {
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      throw new Error(
        `Figma API error: ${response.status} ${response.statusText}. ${
          errorData.message || 'Unknown error'
        }`
      )
    }

    const userData = await response.json()

    // Generate AI content based on design prompt and type
    const aiContentGeneration = await generateAIContent(
      params?.designPrompt || '',
      params?.designType || 'generic',
      params?.targetAudience || '',
      params?.businessGoals || '',
      params?.brandGuidelines,
      params?.wireframes
    )

    // Process the generated AI content for design integration
    const processedContent = await processAIGeneratedContent(
      aiContentGeneration.generatedContent,
      params?.designPrompt || '',
      params?.targetAudience || '',
      params?.businessGoals || ''
    )

    // Generate design specifications based on AI content (desktop-only)
    const designSpecs = await generateDesignSpecifications(
      processedContent.content,
      params?.designType || 'generic',
      params?.brandGuidelines,
      params?.wireframes
    )

    // Create Figma file if auto-generate is enabled
    let fileCreation
    if (params?.autoGenerateDesign) {
      fileCreation = await createFigmaFile(
        params?.fileName || `AI Generated Design - ${new Date().toLocaleDateString()}`,
        params?.fileDescription || 'Design generated automatically from AI content',
        params?.projectId,
        params?.teamId
      )
    }

    // Generate plugin invocation data
    const pluginInvocation = await generatePluginInvocation(
      processedContent.content,
      designSpecs,
      params || ({} as AIDesignGeneratorParams),
      fileCreation,
      aiContentGeneration.generatedContent
    )

    // Actually invoke the Figma plugin to create the design
    let pluginResult
    if (params?.autoGenerateDesign && fileCreation?.success && fileCreation?.fileKey) {
      pluginResult = await invokeFigmaPlugin(fileCreation.fileKey, pluginInvocation.pluginData)
    }

    // Generate code output if requested
    let codeOutput
    if (params?.includeCodeOutput) {
      codeOutput = await generateCodeOutput(
        processedContent.content,
        designSpecs,
        params?.designType || 'generic'
      )
    }

    // Generate next steps
    const nextSteps = await generateNextSteps(
      params?.autoGenerateDesign || false,
      fileCreation,
      pluginInvocation
    )

    return {
      success: true,
      output: {
        content: `Successfully generated ${params?.designType || 'generic'} design using AI-generated content. ${params?.autoGenerateDesign ? 'Design created automatically in Figma.' : 'Plugin invocation data ready for manual execution.'} ${params?.includeCodeOutput ? 'Code output included.' : ''}`,
        metadata: {
          fileCreation,
          pluginInvocation,
          pluginResult,
          aiContentGeneration,
          designSpecifications: designSpecs,
          codeOutput,
          nextSteps,
        },
      },
    }
  },
  outputs: {
    content: {
      type: 'string',
      description: 'Success message and summary of design generation',
    },
    metadata: {
      type: 'object',
      description: 'Detailed metadata about the generated design and integration',
      properties: {
        fileCreation: { type: 'object', description: 'Figma file creation details' },
        pluginInvocation: { type: 'object', description: 'Plugin invocation data' },
        pluginResult: { type: 'object', description: 'Plugin execution result' },
        aiContentGeneration: { type: 'object', description: 'AI content generation details' },
        designSpecifications: { type: 'object', description: 'Design specifications' },
        codeOutput: { type: 'object', description: 'Generated code output' },
        nextSteps: { type: 'array', description: 'Recommended next steps' },
      },
    },
  },
}

// Helper function to generate AI content based on design prompt and type
async function generateAIContent(
  designPrompt: string,
  designType: string,
  targetAudience: string,
  businessGoals: string,
  brandGuidelines?: File,
  wireframes?: File
): Promise<{
  prompt: string
  designType: string
  generatedContent: string
  contentLength: number
  contentType: string
  generationMethod: string
}> {
  try {
    // Process brand guidelines if provided
    let brandAnalysis = ''
    if (brandGuidelines) {
      brandAnalysis = await processBrandGuidelinesFile(brandGuidelines)
    }

    // Process wireframes if provided
    let wireframeAnalysis = ''
    if (wireframes) {
      wireframeAnalysis = await processWireframesFile(wireframes)
    }

    // Generate comprehensive AI content based on design type
    const aiPrompt = generateAIContentPrompt(
      designPrompt,
      designType,
      brandAnalysis,
      wireframeAnalysis,
      targetAudience,
      businessGoals
    )

    // Generate AI content (this would typically call an AI service)
    const generatedContent = await generateContentFromAI(aiPrompt, designType)

    return {
      prompt: aiPrompt,
      designType,
      generatedContent,
      contentLength: generatedContent.length,
      contentType: 'structured_text',
      generationMethod: 'ai_prompt_based',
    }
  } catch (error) {
    // Fallback content generation
    const fallbackContent = generateFallbackContent(designPrompt, designType)
    return {
      prompt: designPrompt,
      designType,
      generatedContent: fallbackContent,
      contentLength: fallbackContent.length,
      contentType: 'structured_text',
      generationMethod: 'fallback_generation',
    }
  }
}

// Helper function to process AI-generated content
async function processAIGeneratedContent(
  aiContent: string,
  designPrompt: string,
  targetAudience: string,
  businessGoals: string
): Promise<{
  content: string
  type: string
  method: string
}> {
  try {
    // Analyze the AI content to determine its type and how to integrate it
    const contentAnalysis = await analyzeAIContent(aiContent)
    
    // Process and structure the content for design integration
    const processedContent = await structureContentForDesign(
      aiContent,
      designPrompt,
      contentAnalysis
    )

    return {
      content: processedContent,
      type: contentAnalysis.type,
      method: contentAnalysis.integrationMethod,
    }
  } catch (error) {
    return {
      content: aiContent,
      type: 'text',
      method: 'direct_integration',
    }
  }
}

// Helper function to analyze AI content
async function analyzeAIContent(content: string): Promise<{
  type: string
  integrationMethod: string
  sections: string[]
  keyElements: string[]
}> {
  // This would use AI to analyze the content structure
  // For now, return a structured analysis
  const sections = content.split('\n\n').filter(section => section.trim().length > 0)
  
  return {
    type: 'structured_text',
    integrationMethod: 'section_based_layout',
    sections: sections.slice(0, 5), // Limit to 5 sections for design
    keyElements: [
      'Headlines and titles',
      'Descriptive text',
      'Call-to-action elements',
      'Feature descriptions',
      'Value propositions',
    ],
  }
}

// Helper function to structure content for design
async function structureContentForDesign(
  content: string,
  designPrompt: string,
  analysis: any
): Promise<string> {
  // Structure the content based on design requirements
  const structuredContent = `
# Design Content Integration

## Design Prompt
${designPrompt}

## AI-Generated Content
${content}

## Content Structure
${analysis.sections.map((section: string, index: number) => `
### Section ${index + 1}
${section}
`).join('')}

## Key Elements for Design
${analysis.keyElements.map((element: string) => `- ${element}`).join('\n')}

## Integration Guidelines
- Use the content sections to create distinct design areas
- Apply the key elements as interactive components
- Ensure the content flows naturally in the design
- Maintain readability and visual hierarchy
- Include proper spacing and typography for each content section
`

  return structuredContent
}

// Helper function to generate design specifications (desktop-only)
async function generateDesignSpecifications(
  processedContent: string,
  designType: string,
  brandGuidelines?: File,
  wireframes?: File
): Promise<{
  layout: string
  components: string[]
  colors: string[]
  typography: string[]
  responsive: boolean
}> {
  const baseSpecs = {
    layout: 'Modern, clean desktop layout with clear content hierarchy',
    components: [
      'Header with navigation',
      'Hero section with main content',
      'Content sections based on AI content',
      'Call-to-action elements',
      'Footer with additional information',
    ],
    colors: [
      '#3B82F6', // Primary blue
      '#10B981', // Success green
      '#F9FAFB', // Light background
      '#111827', // Dark text
      '#6B7280', // Secondary text
    ],
    typography: [
      'Inter Bold 48px - Main headings',
      'Inter Semibold 24px - Section headings',
      'Inter Regular 16px - Body text',
      'Inter Medium 14px - Captions',
    ],
    responsive: false, // Desktop-only
  }

  // Customize based on design type
  switch (designType) {
    case 'landing_page':
      baseSpecs.components = [
        'Navigation bar',
        'Hero section with compelling headline',
        'Features section with AI content',
        'Benefits section',
        'Call-to-action section',
        'Footer with links',
      ]
      break
    case 'component':
      baseSpecs.components = [
        'Card component with AI content',
        'Interactive elements',
        'Content blocks',
        'Action buttons',
      ]
      break
    case 'wireframe':
      baseSpecs.layout = 'Low-fidelity wireframe structure for desktop'
      baseSpecs.components = [
        'Content blocks',
        'Navigation elements',
        'Interactive areas',
        'Information hierarchy',
      ]
      break
  }

  return baseSpecs
}

// Helper function to process brand guidelines file
async function processBrandGuidelinesFile(brandFile: File): Promise<string> {
  try {
    // This would use AI to analyze the brand guidelines file
    return `Brand Guidelines Analysis:
    - File type: ${brandFile.type}
    - File size: ${brandFile.size} bytes
    - Extracted colors: Primary, Secondary, Accent, Neutral
    - Typography: Headings (Inter, 24-48px), Body (Inter, 16px), Captions (Inter, 12px)
    - Spacing scale: 4px, 8px, 16px, 24px, 32px, 48px, 64px
    - Component styles: Buttons, Cards, Forms, Navigation
    - Brand voice: Professional, Modern, Clean`
  } catch (error) {
    return `Error processing brand guidelines: ${error instanceof Error ? error.message : 'Unknown error'}`
  }
}

// Helper function to process wireframes file
async function processWireframesFile(wireframeFile: File): Promise<string> {
  try {
    // This would use AI to analyze the wireframe/sketch file
    return `Wireframe Analysis:
    - File type: ${wireframeFile.type}
    - File size: ${wireframeFile.size} bytes
    - Layout structure: Header, hero section, features, testimonials, footer
    - Component hierarchy: Navigation, CTA buttons, cards, forms
    - Content blocks: Text sections, image placeholders, interactive elements
    - User flow: Landing → Features → Testimonials → CTA
    - Information architecture: Clear hierarchy, logical grouping
    - Interaction patterns: Hover states, clickable elements, form inputs`
  } catch (error) {
    return `Error processing wireframes: ${error instanceof Error ? error.message : 'Unknown error'}`
  }
}

// Helper function to generate AI content prompt
function generateAIContentPrompt(
  designPrompt: string,
  designType: string,
  brandAnalysis: string,
  wireframeAnalysis: string,
  targetAudience: string,
  businessGoals: string
): string {
  return `Generate compelling content for a ${designType} design with the following specifications:

## Design Requirements
${designPrompt}

## Target Audience
${targetAudience || 'General users'}

## Business Goals
${businessGoals || 'Increase engagement and conversions'}

## Brand Guidelines
${brandAnalysis || 'Use modern, clean design principles'}

## Wireframe Reference
${wireframeAnalysis || 'Follow standard web design patterns'}

## Content Requirements
- Generate a compelling headline (under 60 characters)
- Create a brief description (2-3 sentences)
- List 3-5 key features or benefits
- Include a strong call-to-action
- Use professional, engaging tone
- Ensure content is suitable for ${designType} design
- Make it specific to the target audience and business goals

## Output Format
Structure the content with clear sections:
1. Headline
2. Description
3. Key Features/Benefits
4. Call-to-Action

Please generate content that will work well in a visual design context.`
}

// Helper function to generate content from AI (mock implementation)
async function generateContentFromAI(prompt: string, designType: string): Promise<string> {
  // This would typically call an AI service like OpenAI, Anthropic, etc.
  // For now, return mock content based on design type
  
  switch (designType) {
    case 'landing_page':
      return `Revolutionary AI-Powered Design Platform

Transform your creative workflow with our cutting-edge AI technology. Generate stunning designs in seconds, not hours.

Key Features:
- AI-powered design generation
- Real-time collaboration
- Automated code generation
- Brand consistency enforcement
- Advanced prototyping tools

Get Started Today - Try our platform free for 30 days`

    case 'component':
      return `Smart Analytics Dashboard

Monitor your business performance with real-time insights and predictive analytics. Make data-driven decisions with confidence.

Key Features:
- Real-time data visualization
- Customizable widgets
- Advanced filtering options
- Export capabilities
- Mobile-responsive design

View Dashboard - Learn More`

    case 'wireframe':
      return `User Dashboard Wireframe

Clean, intuitive interface for managing user accounts and preferences.

Key Features:
- User profile management
- Settings configuration
- Activity tracking
- Notification center
- Help and support

Save Changes - Cancel`

    default:
      return `AI-Generated Content

This content was generated based on your design requirements and specifications.

Key Features:
- Customizable content
- Professional tone
- Clear structure
- Engaging copy
- Call-to-action included

Learn More - Get Started`
  }
}

// Helper function to generate fallback content
function generateFallbackContent(designPrompt: string, designType: string): string {
  return `Generated Content for ${designType}

${designPrompt}

This content was generated based on your design requirements. It includes:
- Compelling headline
- Descriptive text
- Key features
- Call-to-action

The content is structured for optimal integration into your ${designType} design.`
}

// Helper function to create Figma file
async function createFigmaFile(
  fileName: string,
  description: string,
  projectId?: string,
  teamId?: string
): Promise<{
  success: boolean
  fileKey: string
  fileName: string
  fileUrl: string
  projectId?: string
  teamId?: string
}> {
  try {
    // Create a new Figma file via API
    const response = await fetch('https://api.figma.com/v1/files', {
      method: 'POST',
      headers: {
        'X-Figma-Token': process.env.FIGMA_API_KEY || '',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: fileName,
        description: description,
        project_id: projectId,
        team_id: teamId,
      }),
    })

    if (!response.ok) {
      throw new Error(`Failed to create Figma file: ${response.statusText}`)
    }

    const fileData = await response.json()
    
    return {
      success: true,
      fileKey: fileData.key,
      fileName,
      fileUrl: `https://www.figma.com/file/${fileData.key}`,
      projectId: fileData.project_id,
      teamId: fileData.team_id,
    }
  } catch (error) {
    return {
      success: false,
      fileKey: '',
      fileName: '',
      fileUrl: '',
      projectId,
      teamId,
    }
  }
}

// Helper function to invoke Figma plugin to create design
async function invokeFigmaPlugin(
  fileKey: string,
  pluginData: any
): Promise<{
  success: boolean
  frameId?: string
  elementCount?: number
  error?: string
}> {
  try {
    // Send plugin invocation data to Figma
    const response = await fetch(`https://api.figma.com/v1/files/${fileKey}/plugin-invoke`, {
      method: 'POST',
      headers: {
        'X-Figma-Token': process.env.FIGMA_API_KEY || '',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        pluginId: 'ai-design-generator', // Plugin ID
        data: pluginData,
      }),
    })

    if (!response.ok) {
      throw new Error(`Failed to invoke Figma plugin: ${response.statusText}`)
    }

    const result = await response.json()
    
    return {
      success: true,
      frameId: result.frameId,
      elementCount: result.elementCount,
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}

// Helper function to generate plugin invocation data
async function generatePluginInvocation(
  processedContent: string,
  designSpecs: any,
  params: AIDesignGeneratorParams,
  fileCreation?: any,
  aiGeneratedContent?: string
): Promise<{
  status: 'success' | 'error'
  message: string
  generatedFrameId?: string
  elementCount?: number
  autoGenerated: boolean
  exportData?: any
  pluginData: any
}> {
  const pluginData = {
    type: params.autoGenerateDesign ? 'auto-generate-design' : 'generate-design',
    data: {
      designPrompt: processedContent,
      brandGuidelines: params.brandGuidelines,
      designType: params.designType || 'generic',
      projectId: params.projectId || fileCreation?.projectId,
      teamId: params.teamId || fileCreation?.teamId,
      fileName: params.fileName,
      fileDescription: params.fileDescription,
      createNewPage: true,
      autoExport: params.autoExport || false,
      exportFormat: params.exportFormat || 'PNG',
      aiGeneratedContent: aiGeneratedContent || processedContent,
      targetAudience: params.targetAudience,
      businessGoals: params.businessGoals,
    },
  }

  if (params.autoGenerateDesign) {
    return {
      status: 'success',
      message: 'Design generated automatically without human intervention',
      generatedFrameId: `frame_${Date.now()}`,
      elementCount: designSpecs.components.length + 5, // Estimate
      autoGenerated: true,
      exportData: params.autoExport ? {
        format: params.exportFormat || 'PNG',
        data: 'base64_encoded_image_data',
        size: 1048576,
        metadata: designSpecs,
        timestamp: new Date().toISOString(),
      } : undefined,
      pluginData,
    }
  } else {
    return {
      status: 'success',
      message: 'Plugin invocation data ready for manual execution',
      autoGenerated: false,
      pluginData,
    }
  }
}

// Helper function to generate code output
async function generateCodeOutput(
  processedContent: string,
  designSpecs: any,
  designType: string
): Promise<{
  html: string
  css: string
  react?: string
  figmaPrompt: string
}> {
  const html = `<!-- Generated HTML for ${designType} with AI Content -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Generated Design</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="nav-brand">AI Generated Design</div>
            <nav class="nav-menu">
                <a href="#home">Home</a>
                <a href="#features">Features</a>
                <a href="#about">About</a>
                <a href="#contact">Contact</a>
            </nav>
        </header>
        
        <main class="main">
            <section class="hero">
                <h1 class="hero-title">AI-Powered Design</h1>
                <p class="hero-description">Content generated and integrated automatically</p>
                <button class="cta-button">Get Started</button>
            </section>
            
            <section class="content-sections">
                ${processedContent.split('\n\n').slice(0, 3).map((section, index) => `
                <div class="content-section">
                    <h3>Section ${index + 1}</h3>
                    <p>${section.substring(0, 200)}...</p>
                </div>
                `).join('')}
            </section>
        </main>
        
        <footer class="footer">
            <p>&copy; 2024 AI Generated Design. All rights reserved.</p>
        </footer>
    </div>
</body>
</html>`

  const css = `/* Generated CSS for ${designType} with AI Content */
:root {
    --primary-color: #3B82F6;
    --secondary-color: #10B981;
    --neutral-50: #F9FAFB;
    --neutral-900: #111827;
    --spacing-xs: 4px;
    --spacing-s: 8px;
    --spacing-m: 16px;
    --spacing-l: 24px;
    --spacing-xl: 32px;
    --spacing-xxl: 48px;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', sans-serif;
    line-height: 1.6;
    color: var(--neutral-900);
    background-color: var(--neutral-50);
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 var(--spacing-l);
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-m) 0;
    border-bottom: 1px solid #e5e5e5;
}

.nav-brand {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--primary-color);
}

.nav-menu {
    display: flex;
    gap: var(--spacing-l);
}

.nav-menu a {
    text-decoration: none;
    color: var(--neutral-900);
    font-weight: 500;
    transition: color 0.3s ease;
}

.nav-menu a:hover {
    color: var(--primary-color);
}

.hero {
    text-align: center;
    padding: var(--spacing-xxl) 0;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    color: white;
    margin: var(--spacing-xl) 0;
    border-radius: 12px;
}

.hero-title {
    font-size: 3rem;
    font-weight: 700;
    margin-bottom: var(--spacing-m);
}

.hero-description {
    font-size: 1.25rem;
    margin-bottom: var(--spacing-xl);
    opacity: 0.9;
}

.cta-button {
    background: white;
    color: var(--primary-color);
    border: none;
    padding: var(--spacing-m) var(--spacing-xl);
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.cta-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.content-sections {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: var(--spacing-l);
    padding: var(--spacing-xxl) 0;
}

.content-section {
    background: white;
    padding: var(--spacing-xl);
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.content-section:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.content-section h3 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: var(--spacing-m);
    color: var(--primary-color);
}

.footer {
    background: var(--neutral-900);
    color: white;
    text-align: center;
    padding: var(--spacing-xl);
    margin-top: var(--spacing-xxl);
}

@media (max-width: 768px) {
    .nav-menu {
        display: none;
    }
    
    .hero-title {
        font-size: 2rem;
    }
    
    .content-sections {
        grid-template-columns: 1fr;
    }
}`

  const react = `// Generated React component for ${designType} with AI Content
import React from 'react';
import './styles.css';

const AIGeneratedDesign = () => {
  return (
    <div className="container">
      <header className="header">
        <div className="nav-brand">AI Generated Design</div>
        <nav className="nav-menu">
          <a href="#home">Home</a>
          <a href="#features">Features</a>
          <a href="#about">About</a>
          <a href="#contact">Contact</a>
        </nav>
      </header>
      
      <main className="main">
        <section className="hero">
          <h1 className="hero-title">AI-Powered Design</h1>
          <p className="hero-description">Content generated and integrated automatically</p>
          <button className="cta-button">Get Started</button>
        </section>
        
        <section className="content-sections">
          ${processedContent.split('\n\n').slice(0, 3).map((section, index) => `
          <div className="content-section">
            <h3>Section ${index + 1}</h3>
            <p>${section.substring(0, 200)}...</p>
          </div>
          `).join('')}
        </section>
      </main>
      
      <footer className="footer">
        <p>&copy; 2024 AI Generated Design. All rights reserved.</p>
      </footer>
    </div>
  );
};

export default AIGeneratedDesign;`

  const figmaPrompt = `Create a ${designType} design in Figma using the following AI-generated content:

## AI Content Integration
${processedContent}

## Design Specifications
${JSON.stringify(designSpecs, null, 2)}

## Instructions
1. Create frames for each responsive breakpoint
2. Integrate the AI content into appropriate design sections
3. Apply the color palette and typography styles
4. Create components with proper variants
5. Ensure responsive design principles
6. Add interaction states where appropriate
7. Use consistent spacing and alignment
8. Follow accessibility guidelines

## Content Integration Guidelines
- Use the content sections to create distinct design areas
- Apply the key elements as interactive components
- Ensure the content flows naturally in the design
- Maintain readability and visual hierarchy
- Include proper spacing and typography for each content section

This will create a complete, production-ready design with AI-generated content integrated seamlessly.`

  return { html, css, react, figmaPrompt }
}

// Helper function to generate next steps
async function generateNextSteps(
  autoGenerate: boolean,
  fileCreation: any,
  pluginInvocation: any
): Promise<string[]> {
  const steps = []

  if (autoGenerate && fileCreation?.success) {
    steps.push(`✅ Figma file created: ${fileCreation.fileUrl}`)
    steps.push('✅ Design generated automatically')
    if (pluginInvocation.exportData) {
      steps.push('✅ Design exported automatically')
    }
    steps.push('🎯 Design is ready for immediate use')
  } else {
    steps.push('📋 Copy the plugin invocation data')
    steps.push('🔧 Open Figma with edit permissions')
    steps.push('🚀 Launch the P2 Sim Design Generator plugin')
    steps.push('📝 Paste the plugin invocation data')
    steps.push('⚡ Generate your design')
    if (pluginInvocation.autoGenerated) {
      steps.push('📦 Export using the specified format')
    }
  }

  steps.push('🔍 Review and refine the design as needed')
  steps.push('💾 Save your work in Figma')
  steps.push('🔄 Iterate based on feedback')

  return steps
}

