// =====================================================
// P2 Sim Design Generator Plugin
// =====================================================

// ‚úÖ Show the UI FIRST to ensure message channel is ready
figma.showUI(__html__, { width: 400, height: 600 });

// Plugin state management
let pluginState = {
  isGenerating: false,
  currentDesign: null,
  designHistory: []
};

// =====================================================
// üîÑ Handle messages from UI and external sources
// =====================================================
figma.ui.onmessage = async (msg) => {
  console.log('üì® Plugin received message:', msg);

  try {
    switch (msg.type) {
      case 'generate-design':
        await handleGenerateDesign(msg.data);
        break;
      case 'auto-generate-design':
        await handleAutoGenerateDesign(msg.data);
        break;
      case 'export-design':
        await handleExportDesign();
        break;
      case 'load-design':
        await handleLoadDesign(msg.data);
        break;
      case 'close-plugin':
        figma.closePlugin();
        break;
      default:
        console.warn('‚ö†Ô∏è Unknown message type:', msg.type);
    }
  } catch (error) {
    console.error('‚ùå Error handling message:', error);
    figma.notify('Error in plugin: ' + error.message);
  }
};

// =====================================================
// ü§ñ Auto-generate design without UI interaction
// =====================================================
async function handleAutoGenerateDesign(data) {
  try {
    pluginState.isGenerating = true;
    figma.notify('üöÄ Auto-generating design with AI content...');

    const { 
      designPrompt, 
      brandGuidelines, 
      designType, 
      projectId, 
      teamId, 
      fileName,
      fileDescription,
      createNewPage = true,
      autoExport = false,
      exportFormat = 'PNG',
      aiGeneratedContent,
      targetAudience,
      businessGoals
    } = data;

    // Check if we're in read-only mode
    if (figma.mode === 'readonly') {
      throw new Error('Cannot create designs in read-only mode. Please open a file you have edit permissions for.');
    }

    // Show project information if provided
    if (projectId) {
      figma.notify(`üìÅ Target Project: ${projectId}${teamId ? ` (Team: ${teamId})` : ''}`);
    }

    // Load fonts
    await figma.loadFontAsync({ family: 'Inter', style: 'Regular' });

    // Create a new page for the design if requested
    let targetPage = figma.currentPage;
    if (createNewPage) {
      targetPage = figma.createPage();
      targetPage.name = fileName || `AI Design - ${designType.replace('_', ' ').toUpperCase()} - ${new Date().toLocaleDateString()}`;
    }

    // Create base frame
    const frame = figma.createFrame();
    frame.name = `AI Generated Design - ${new Date().toLocaleString()}`;
    frame.resize(1200, 800);
    frame.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
    frame.x = 0;
    frame.y = 0;
    targetPage.appendChild(frame);

    figma.notify(`üß© Creating ${designType} with AI content...`);
    console.log(`Auto-generating ${designType} with prompt:`, designPrompt);
    console.log(`AI-generated content:`, aiGeneratedContent);

    let generatedElements = [];

    // Process AI-generated content for design integration
    const processedContent = await processAIContentForDesign(aiGeneratedContent, designPrompt, targetAudience, businessGoals);

    switch (designType) {
      case 'landing_page':
        generatedElements = await generateLandingPageWithAIContent(frame, processedContent, brandGuidelines);
        break;
      case 'component':
        generatedElements = await generateComponentWithAIContent(frame, processedContent, brandGuidelines);
        break;
      case 'wireframe':
        generatedElements = await generateWireframeWithAIContent(frame, processedContent, brandGuidelines);
        break;
      default:
        generatedElements = await generateGenericDesignWithAIContent(frame, processedContent, brandGuidelines);
    }

    // Note: Desktop-only design (no responsive breakpoints applied)

    pluginState.currentDesign = {
      frame,
      elements: generatedElements,
      metadata: {
        prompt: designPrompt,
        type: designType,
        timestamp: new Date().toISOString(),
        brandGuidelines,
        autoGenerated: true
      }
    };

    pluginState.designHistory.push(pluginState.currentDesign);

    // Focus on the generated frame
    figma.viewport.scrollAndZoomIntoView([frame]);

    figma.notify('‚úÖ Design auto-generated successfully!');
    console.log('‚úÖ Design auto-generated successfully', pluginState.currentDesign);

    // Auto-export if requested
    if (autoExport) {
      await handleAutoExport(exportFormat);
    }

    pluginState.isGenerating = false;

    // Send success message to external systems
    if (figma.ui.postMessage) {
      figma.ui.postMessage({
        type: 'auto-generation-completed',
        data: {
          success: true,
          frameId: frame.id,
          elementCount: generatedElements.length,
          fileKey: figma.fileKey,
          pageId: targetPage.id,
          exportData: autoExport ? await getExportData(exportFormat) : null
        }
      });
    }

  } catch (error) {
    console.error('‚ùå Error auto-generating design:', error);
    figma.notify('‚ùå Error: ' + error.message);
    pluginState.isGenerating = false;
    
    if (figma.ui.postMessage) {
      figma.ui.postMessage({
        type: 'auto-generation-error',
        data: { error: error.message }
      });
    }
  }
}

// =====================================================
// üì§ Auto-export functionality
// =====================================================
async function handleAutoExport(format = 'PNG') {
  if (!pluginState.currentDesign) {
    throw new Error('No design to export');
  }

  try {
    const { frame } = pluginState.currentDesign;
    const imageBytes = await frame.exportAsync({ 
      format: format.toUpperCase(), 
      constraint: { type: 'SCALE', value: 2 } 
    });
    const base64 = figma.base64Encode(imageBytes);

    figma.notify(`üì¶ Auto-exported as ${format.toUpperCase()}`);
    
    return {
      format: format.toUpperCase(),
      data: base64,
      size: imageBytes.length
    };
  } catch (error) {
    console.error('‚ùå Auto-export error:', error);
    figma.notify('‚ùå Auto-export failed: ' + error.message);
    throw error;
  }
}

// =====================================================
// üìä Get export data for external systems
// =====================================================
async function getExportData(format = 'PNG') {
  try {
    const exportResult = await handleAutoExport(format);
    return {
      ...exportResult,
      metadata: pluginState.currentDesign?.metadata,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('‚ùå Error getting export data:', error);
    return null;
  }
}

// =====================================================
// üé® Generate design based on user input
// =====================================================
async function handleGenerateDesign(data) {
  try {
    pluginState.isGenerating = true;
    figma.ui.postMessage({ type: 'generation-started' });
    figma.notify('üöÄ Generating design...');

    const { designPrompt, brandGuidelines, designType, responsiveBreakpoints, projectId, teamId, figmaFileKey } = data;

    // Check if we're in read-only mode
    if (figma.mode === 'readonly') {
      throw new Error('Cannot create designs in read-only mode. Please open a file you have edit permissions for.');
    }

    // Show project information if provided
    if (projectId) {
      figma.notify(`üìÅ Target Project: ${projectId}${teamId ? ` (Team: ${teamId})` : ''}`);
      
      // Check if we're in the correct project
      const currentFile = figma.root;
      const currentFileId = figma.fileKey;
      
      if (figmaFileKey && currentFileId !== figmaFileKey) {
        figma.notify(`‚ö†Ô∏è You're in file ${currentFileId}, but target is ${figmaFileKey}`);
        figma.ui.postMessage({ 
          type: 'project-mismatch', 
          data: { 
            currentFile: currentFileId, 
            targetFile: figmaFileKey,
            projectId,
            teamId 
          } 
        });
      }
    }

    // ‚úÖ Load fonts once globally
    await figma.loadFontAsync({ family: 'Inter', style: 'Regular' });

    // Create a new page for the design if requested
    let targetPage = figma.currentPage;
    if (data.createNewPage) {
      targetPage = figma.createPage();
      targetPage.name = `Design - ${designType.replace('_', ' ').toUpperCase()} - ${new Date().toLocaleDateString()}`;
    }

    // Create base frame
    const frame = figma.createFrame();
    frame.name = `Generated Design - ${new Date().toLocaleString()}`;
    frame.resize(1200, 800);
    frame.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
    frame.x = 0;
    frame.y = 0;
    targetPage.appendChild(frame);

    figma.notify(`üß© Creating ${designType}...`);
    console.log(`Generating ${designType} with prompt:`, designPrompt);

    let generatedElements = [];

    switch (designType) {
      case 'landing_page':
        generatedElements = await generateLandingPage(frame, designPrompt, brandGuidelines);
        break;
      case 'component':
        generatedElements = await generateComponent(frame, designPrompt, brandGuidelines);
        break;
      case 'wireframe':
        generatedElements = await generateWireframe(frame, designPrompt, brandGuidelines);
        break;
      default:
        generatedElements = await generateGenericDesign(frame, designPrompt, brandGuidelines);
    }

    // Note: Desktop-only design (no responsive breakpoints applied)

    pluginState.currentDesign = {
      frame,
      elements: generatedElements,
      metadata: {
        prompt: designPrompt,
        type: designType,
        timestamp: new Date().toISOString(),
        brandGuidelines
      }
    };

    pluginState.designHistory.push(pluginState.currentDesign);

    // Focus on the generated frame
    figma.viewport.scrollAndZoomIntoView([frame]);

    figma.notify('‚úÖ Design generated successfully!');
    console.log('‚úÖ Design generated successfully', pluginState.currentDesign);

    pluginState.isGenerating = false;
    figma.ui.postMessage({
      type: 'generation-completed',
      data: {
        success: true,
        frameId: frame.id,
        elementCount: generatedElements.length
      }
    });
  } catch (error) {
    console.error('‚ùå Error generating design:', error);
    figma.notify('‚ùå Error: ' + error.message);
    pluginState.isGenerating = false;
    figma.ui.postMessage({
      type: 'generation-error',
      data: { error: error.message }
    });
  }
}

// =====================================================
// ü§ñ AI Content Processing Functions
// =====================================================

// Process AI-generated content for design integration
async function processAIContentForDesign(aiContent, designPrompt, targetAudience, businessGoals) {
  try {
    // Parse and structure the AI content
    const contentSections = aiContent.split('\n\n').filter(section => section.trim().length > 0);
    
    // Extract key elements from the content
    const keyElements = {
      headlines: contentSections.filter(section => section.length < 100 && section.includes(' ')),
      descriptions: contentSections.filter(section => section.length > 100),
      callToActions: contentSections.filter(section => 
        section.toLowerCase().includes('get') || 
        section.toLowerCase().includes('start') || 
        section.toLowerCase().includes('try') ||
        section.toLowerCase().includes('learn')
      ),
      features: contentSections.filter(section => 
        section.toLowerCase().includes('feature') || 
        section.toLowerCase().includes('benefit') ||
        section.toLowerCase().includes('advantage')
      )
    };

    return {
      sections: contentSections.slice(0, 5), // Limit to 5 sections
      keyElements,
      designPrompt,
      targetAudience: targetAudience || 'General users',
      businessGoals: businessGoals || 'Increase engagement and conversions',
      totalLength: aiContent.length
    };
  } catch (error) {
    console.error('Error processing AI content:', error);
    return {
      sections: [aiContent],
      keyElements: {
        headlines: [aiContent.substring(0, 50) + '...'],
        descriptions: [aiContent],
        callToActions: ['Get Started'],
        features: ['Key Features']
      },
      designPrompt,
      targetAudience: targetAudience || 'General users',
      businessGoals: businessGoals || 'Increase engagement and conversions',
      totalLength: aiContent.length
    };
  }
}

// =====================================================
// üõ†Ô∏è Helper Functions
// =====================================================

// Parse brand guidelines to extract colors
function parseBrandGuidelines(guidelines) {
  if (!guidelines) return {};
  
  const colors = {};
  const colorRegex = /#([0-9a-fA-F]{6})/g;
  const matches = guidelines.match(colorRegex);
  
  if (matches) {
    colors.primary = hexToRgb(matches[0]);
    colors.secondary = hexToRgb(matches[1]) || { r: 0.95, g: 0.95, b: 0.95 };
    colors.text = hexToRgb(matches[2]) || { r: 0.1, g: 0.1, b: 0.1 };
  }
  
  return colors;
}

// Convert hex to RGB
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16) / 255,
    g: parseInt(result[2], 16) / 255,
    b: parseInt(result[3], 16) / 255
  } : null;
}

// Extract title from prompt
function extractTitleFromPrompt(prompt) {
  const sentences = prompt.split('.');
  return sentences[0].substring(0, 50) + (sentences[0].length > 50 ? '...' : '');
}

// =====================================================
// üß± AI-Powered Design Generators
// =====================================================

// Generate landing page with AI content
async function generateLandingPageWithAIContent(frame, processedContent, brandGuidelines) {
  const elements = [];
  const brandColors = parseBrandGuidelines(brandGuidelines);
  const primaryColor = brandColors.primary || { r: 0.2, g: 0.4, b: 0.8 };

  // Header with AI-generated navigation
  const header = figma.createFrame();
  header.name = 'Header';
  header.resize(frame.width, 80);
  header.fills = [{ type: 'SOLID', color: { r: 0.95, g: 0.95, b: 0.95 } }];
  frame.appendChild(header);
  elements.push(header);

  const logo = figma.createRectangle();
  logo.name = 'Logo';
  logo.resize(120, 40);
  logo.fills = [{ type: 'SOLID', color: primaryColor }];
  logo.x = 40;
  logo.y = 20;
  header.appendChild(logo);
  elements.push(logo);

  // AI-generated navigation items
  const navItems = processedContent.keyElements.headlines.slice(0, 4) || ['Home', 'About', 'Services', 'Contact'];
  for (let i = 0; i < navItems.length; i++) {
    const navItem = figma.createText();
    navItem.characters = navItems[i].substring(0, 20); // Limit length
    navItem.fontSize = 16;
    navItem.fills = [{ type: 'SOLID', color: { r: 0.2, g: 0.2, b: 0.2 } }];
    navItem.x = frame.width - 250 + i * 60;
    navItem.y = 30;
    header.appendChild(navItem);
    elements.push(navItem);
  }

  // Hero section with AI content
  const hero = figma.createFrame();
  hero.name = 'Hero Section';
  hero.resize(frame.width, 400);
  hero.y = 80;
  hero.fills = [{ type: 'SOLID', color: { r: 0.98, g: 0.98, b: 0.98 } }];
  frame.appendChild(hero);
  elements.push(hero);

  // AI-generated hero title
  const heroTitle = figma.createText();
  heroTitle.characters = processedContent.keyElements.headlines[0] || 'Welcome to Our Platform';
  heroTitle.fontSize = 48;
  heroTitle.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  heroTitle.x = 100;
  heroTitle.y = 150;
  hero.appendChild(heroTitle);
  elements.push(heroTitle);

  // AI-generated hero subtitle
  const heroSubtitle = figma.createText();
  heroSubtitle.characters = processedContent.keyElements.descriptions[0]?.substring(0, 100) || 'Build amazing designs with AI-powered tools';
  heroSubtitle.fontSize = 24;
  heroSubtitle.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  heroSubtitle.x = 100;
  heroSubtitle.y = 220;
  hero.appendChild(heroSubtitle);
  elements.push(heroSubtitle);

  // AI-generated CTA button
  const ctaButton = figma.createRectangle();
  ctaButton.name = 'CTA Button';
  ctaButton.resize(200, 60);
  ctaButton.cornerRadius = 8;
  ctaButton.fills = [{ type: 'SOLID', color: primaryColor }];
  ctaButton.x = 100;
  ctaButton.y = 300;
  hero.appendChild(ctaButton);
  elements.push(ctaButton);

  const buttonText = figma.createText();
  buttonText.characters = processedContent.keyElements.callToActions[0] || 'Get Started';
  buttonText.fontSize = 18;
  buttonText.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  buttonText.x = 150;
  buttonText.y = 320;
  hero.appendChild(buttonText);
  elements.push(buttonText);

  // AI-generated features section
  const featuresSection = figma.createFrame();
  featuresSection.name = 'Features Section';
  featuresSection.resize(frame.width, 300);
  featuresSection.y = 480;
  featuresSection.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  frame.appendChild(featuresSection);
  elements.push(featuresSection);

  // Create feature cards from AI content
  const featureCards = processedContent.keyElements.features.slice(0, 3);
  for (let i = 0; i < featureCards.length; i++) {
    const card = figma.createFrame();
    card.name = `Feature Card ${i + 1}`;
    card.resize(300, 200);
    card.fills = [{ type: 'SOLID', color: { r: 0.99, g: 0.99, b: 0.99 } }];
    card.x = 50 + i * 320;
    card.y = 50;
    card.cornerRadius = 12;
    card.effects = [{
      type: 'DROP_SHADOW',
      color: { r: 0, g: 0, b: 0, a: 0.1 },
      offset: { x: 0, y: 4 },
      radius: 8,
      spread: 0,
      visible: true,
      blendMode: 'NORMAL'
    }];
    featuresSection.appendChild(card);
    elements.push(card);

    const cardTitle = figma.createText();
    cardTitle.characters = `Feature ${i + 1}`;
    cardTitle.fontSize = 18;
    cardTitle.fills = [{ type: 'SOLID', color: primaryColor }];
    cardTitle.x = 20;
    cardTitle.y = 20;
    card.appendChild(cardTitle);
    elements.push(cardTitle);

    const cardDesc = figma.createText();
    cardDesc.characters = featureCards[i]?.substring(0, 120) || 'AI-generated feature description';
    cardDesc.fontSize = 14;
    cardDesc.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
    cardDesc.x = 20;
    cardDesc.y = 60;
    card.appendChild(cardDesc);
    elements.push(cardDesc);
  }

  return elements;
}

// Generate component with AI content
async function generateComponentWithAIContent(frame, processedContent, brandGuidelines) {
  const elements = [];
  const brandColors = parseBrandGuidelines(brandGuidelines);
  const primaryColor = brandColors.primary || { r: 0.2, g: 0.4, b: 0.8 };
  
  // Create a card component with AI content
  const card = figma.createFrame();
  card.name = 'AI Content Card';
  card.resize(400, 300);
  card.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  card.x = 50;
  card.y = 50;
  card.cornerRadius = 16;
  card.effects = [{
    type: 'DROP_SHADOW',
    color: { r: 0, g: 0, b: 0, a: 0.1 },
    offset: { x: 0, y: 8 },
    radius: 24,
    spread: 0,
    visible: true,
    blendMode: 'NORMAL'
  }];
  frame.appendChild(card);
  elements.push(card);
  
  // AI-generated icon
  const icon = figma.createEllipse();
  icon.name = 'AI Icon';
  icon.resize(40, 40);
  icon.fills = [{ type: 'SOLID', color: primaryColor }];
  icon.x = 20;
  icon.y = 20;
  card.appendChild(icon);
  elements.push(icon);
  
  // AI-generated card title
  const cardTitle = figma.createText();
  cardTitle.name = 'AI Card Title';
  cardTitle.characters = processedContent.keyElements.headlines[0] || 'AI Generated Content';
  cardTitle.fontSize = 18;
  cardTitle.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  cardTitle.x = 80;
  cardTitle.y = 25;
  card.appendChild(cardTitle);
  elements.push(cardTitle);
  
  // AI-generated card description
  const cardDesc = figma.createText();
  cardDesc.name = 'AI Card Description';
  cardDesc.characters = processedContent.keyElements.descriptions[0]?.substring(0, 150) || 'This content was generated by AI and integrated into the design automatically.';
  cardDesc.fontSize = 14;
  cardDesc.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  cardDesc.x = 20;
  cardDesc.y = 80;
  card.appendChild(cardDesc);
  elements.push(cardDesc);
  
  // AI-generated action buttons
  const primaryBtn = figma.createRectangle();
  primaryBtn.name = 'AI Primary Button';
  primaryBtn.resize(120, 36);
  primaryBtn.fills = [{ type: 'SOLID', color: primaryColor }];
  primaryBtn.x = 20;
  primaryBtn.y = 200;
  primaryBtn.cornerRadius = 8;
  card.appendChild(primaryBtn);
  elements.push(primaryBtn);
  
  const primaryBtnText = figma.createText();
  primaryBtnText.name = 'AI Primary Button Text';
  primaryBtnText.characters = processedContent.keyElements.callToActions[0] || 'Action';
  primaryBtnText.fontSize = 14;
  primaryBtnText.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  primaryBtnText.x = 50;
  primaryBtnText.y = 210;
  card.appendChild(primaryBtnText);
  elements.push(primaryBtnText);
  
  const secondaryBtn = figma.createRectangle();
  secondaryBtn.name = 'AI Secondary Button';
  secondaryBtn.resize(120, 36);
  secondaryBtn.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  secondaryBtn.strokes = [{ type: 'SOLID', color: primaryColor }];
  secondaryBtn.strokeWeight = 1;
  secondaryBtn.x = 160;
  secondaryBtn.y = 200;
  secondaryBtn.cornerRadius = 8;
  card.appendChild(secondaryBtn);
  elements.push(secondaryBtn);
  
  const secondaryBtnText = figma.createText();
  secondaryBtnText.name = 'AI Secondary Button Text';
  secondaryBtnText.characters = 'Learn More';
  secondaryBtnText.fontSize = 14;
  secondaryBtnText.fills = [{ type: 'SOLID', color: primaryColor }];
  secondaryBtnText.x = 190;
  secondaryBtnText.y = 210;
  card.appendChild(secondaryBtnText);
  elements.push(secondaryBtnText);
  
  return elements;
}

// Generate wireframe with AI content
async function generateWireframeWithAIContent(frame, processedContent, brandGuidelines) {
  const elements = [];
  
  // Create wireframe boxes with AI content labels
  const boxes = [
    { name: 'AI Header', x: 0, y: 0, width: frame.width, height: 60 },
    { name: 'AI Sidebar', x: 0, y: 60, width: 200, height: frame.height - 60 },
    { name: 'AI Main Content', x: 200, y: 60, width: frame.width - 200, height: frame.height - 60 }
  ];
  
  for (const box of boxes) {
    const rect = figma.createRectangle();
    rect.name = box.name;
    rect.resize(box.width, box.height);
    rect.fills = [{ type: 'SOLID', color: { r: 0.9, g: 0.9, b: 0.9 } }];
    rect.strokes = [{ type: 'SOLID', color: { r: 0.5, g: 0.5, b: 0.5 } }];
    rect.strokeWeight = 2;
    rect.x = box.x;
    rect.y = box.y;
    frame.appendChild(rect);
    elements.push(rect);
    
    // Add AI-generated label
    const label = figma.createText();
    label.name = `${box.name} Label`;
    label.characters = box.name;
    label.fontSize = 16;
    label.fills = [{ type: 'SOLID', color: { r: 0.3, g: 0.3, b: 0.3 } }];
    label.x = box.x + 10;
    label.y = box.y + 10;
    frame.appendChild(label);
    elements.push(label);
  }

  // Add AI content sections
  const contentSections = processedContent.sections.slice(0, 3);
  for (let i = 0; i < contentSections.length; i++) {
    const contentBox = figma.createRectangle();
    contentBox.name = `AI Content ${i + 1}`;
    contentBox.resize(300, 80);
    contentBox.fills = [{ type: 'SOLID', color: { r: 0.95, g: 0.95, b: 0.95 } }];
    contentBox.strokes = [{ type: 'SOLID', color: { r: 0.7, g: 0.7, b: 0.7 } }];
    contentBox.strokeWeight = 1;
    contentBox.x = 220;
    contentBox.y = 80 + i * 100;
    frame.appendChild(contentBox);
    elements.push(contentBox);

    const contentLabel = figma.createText();
    contentLabel.name = `AI Content ${i + 1} Label`;
    contentLabel.characters = contentSections[i]?.substring(0, 30) || `AI Content ${i + 1}`;
    contentLabel.fontSize = 12;
    contentLabel.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
    contentLabel.x = 230;
    contentLabel.y = 90 + i * 100;
    frame.appendChild(contentLabel);
    elements.push(contentLabel);
  }
  
  return elements;
}

// Generate generic design with AI content
async function generateGenericDesignWithAIContent(frame, processedContent, brandGuidelines) {
  const elements = [];
  const brandColors = parseBrandGuidelines(brandGuidelines);
  const primaryColor = brandColors.primary || { r: 0.2, g: 0.4, b: 0.8 };
  
  // Create a simple layout based on AI content
  const title = figma.createText();
  title.name = 'AI Generated Title';
  title.characters = processedContent.keyElements.headlines[0] || 'AI Generated Design';
  title.fontSize = 32;
  title.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  title.x = 50;
  title.y = 50;
  frame.appendChild(title);
  elements.push(title);
  
  const description = figma.createText();
  description.name = 'AI Generated Description';
  description.characters = processedContent.keyElements.descriptions[0]?.substring(0, 200) || 'This design was generated by AI and integrated automatically.';
  description.fontSize = 16;
  description.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  description.x = 50;
  description.y = 100;
  frame.appendChild(description);
  elements.push(description);
  
  // Add AI content sections
  const contentSections = processedContent.sections.slice(0, 3);
  for (let i = 0; i < contentSections.length; i++) {
    const contentBox = figma.createFrame();
    contentBox.name = `AI Content Section ${i + 1}`;
    contentBox.resize(350, 120);
    contentBox.fills = [{ type: 'SOLID', color: { r: 0.98, g: 0.98, b: 0.98 } }];
    contentBox.cornerRadius = 8;
    contentBox.x = 50;
    contentBox.y = 200 + i * 140;
    frame.appendChild(contentBox);
    elements.push(contentBox);

    const sectionTitle = figma.createText();
    sectionTitle.name = `AI Section ${i + 1} Title`;
    sectionTitle.characters = `Section ${i + 1}`;
    sectionTitle.fontSize = 18;
    sectionTitle.fills = [{ type: 'SOLID', color: primaryColor }];
    sectionTitle.x = 20;
    sectionTitle.y = 20;
    contentBox.appendChild(sectionTitle);
    elements.push(sectionTitle);

    const sectionContent = figma.createText();
    sectionContent.name = `AI Section ${i + 1} Content`;
    sectionContent.characters = contentSections[i]?.substring(0, 100) || 'AI-generated content section';
    sectionContent.fontSize = 14;
    sectionContent.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
    sectionContent.x = 20;
    sectionContent.y = 50;
    contentBox.appendChild(sectionContent);
    elements.push(sectionContent);
  }
  
  // Add a decorative element
  const decoration = figma.createEllipse();
  decoration.name = 'AI Decoration';
  decoration.resize(100, 100);
  decoration.fills = [{ type: 'SOLID', color: primaryColor }];
  decoration.x = frame.width - 150;
  decoration.y = 50;
  frame.appendChild(decoration);
  elements.push(decoration);
  
  return elements;
}

// =====================================================
// üß± Original Design Generators (for backward compatibility)
// =====================================================
async function generateLandingPage(frame, prompt, brandGuidelines) {
  const elements = [];

  const header = figma.createFrame();
  header.name = 'Header';
  header.resize(frame.width, 80);
  header.fills = [{ type: 'SOLID', color: { r: 0.95, g: 0.95, b: 0.95 } }];
  frame.appendChild(header);
  elements.push(header);

  const logo = figma.createRectangle();
  logo.name = 'Logo';
  logo.resize(120, 40);
  logo.fills = [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 0.8 } }];
  logo.x = 40;
  logo.y = 20;
  header.appendChild(logo);
  elements.push(logo);

  const navItems = ['Home', 'About', 'Services', 'Contact'];
  for (let i = 0; i < navItems.length; i++) {
    const navItem = figma.createText();
    navItem.characters = navItems[i];
    navItem.fontSize = 16;
    navItem.fills = [{ type: 'SOLID', color: { r: 0.2, g: 0.2, b: 0.2 } }];
    navItem.x = frame.width - 250 + i * 60;
    navItem.y = 30;
    header.appendChild(navItem);
    elements.push(navItem);
  }

  const hero = figma.createFrame();
  hero.name = 'Hero Section';
  hero.resize(frame.width, 400);
  hero.y = 80;
  hero.fills = [{ type: 'SOLID', color: { r: 0.98, g: 0.98, b: 0.98 } }];
  frame.appendChild(hero);
  elements.push(hero);

  const heroTitle = figma.createText();
  heroTitle.characters = 'Welcome to Our Platform';
  heroTitle.fontSize = 48;
  heroTitle.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  heroTitle.x = 100;
  heroTitle.y = 150;
  hero.appendChild(heroTitle);
  elements.push(heroTitle);

  const heroSubtitle = figma.createText();
  heroSubtitle.characters = 'Build amazing designs with AI-powered tools';
  heroSubtitle.fontSize = 24;
  heroSubtitle.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  heroSubtitle.x = 100;
  heroSubtitle.y = 220;
  hero.appendChild(heroSubtitle);
  elements.push(heroSubtitle);

  const ctaButton = figma.createRectangle();
  ctaButton.name = 'CTA Button';
  ctaButton.resize(200, 60);
  ctaButton.cornerRadius = 8;
  ctaButton.fills = [{ type: 'SOLID', color: { r: 0.2, g: 0.4, b: 0.8 } }];
  ctaButton.x = 100;
  ctaButton.y = 300;
  hero.appendChild(ctaButton);
  elements.push(ctaButton);

  const buttonText = figma.createText();
  buttonText.characters = 'Get Started';
  buttonText.fontSize = 18;
  buttonText.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  buttonText.x = 150;
  buttonText.y = 320;
  hero.appendChild(buttonText);
  elements.push(buttonText);

  return elements;
}

// Generate component design
async function generateComponent(frame, prompt, brandGuidelines) {
  const elements = [];
  const brandColors = parseBrandGuidelines(brandGuidelines);
  const primaryColor = brandColors.primary || { r: 0.2, g: 0.4, b: 0.8 };
  
  // Create a card component
  const card = figma.createFrame();
  card.name = 'Component Card';
  card.resize(350, 250);
  card.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  card.x = 50;
  card.y = 50;
  card.cornerRadius = 16;
  card.effects = [{
    type: 'DROP_SHADOW',
    color: { r: 0, g: 0, b: 0, a: 0.1 },
    offset: { x: 0, y: 8 },
    radius: 24,
    spread: 0,
    visible: true,
    blendMode: 'NORMAL'
  }];
  frame.appendChild(card);
  elements.push(card);
  
  // Card header with icon
  const icon = figma.createEllipse();
  icon.name = 'Icon';
  icon.resize(40, 40);
  icon.fills = [{ type: 'SOLID', color: primaryColor }];
  icon.x = 20;
  icon.y = 20;
  card.appendChild(icon);
  elements.push(icon);
  
  // Card title
  const cardTitle = figma.createText();
  cardTitle.name = 'Card Title';
  cardTitle.characters = extractTitleFromPrompt(prompt) || 'Component Title';
  cardTitle.fontSize = 18;
  cardTitle.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  cardTitle.x = 80;
  cardTitle.y = 25;
  card.appendChild(cardTitle);
  elements.push(cardTitle);
  
  // Card description
  const cardDesc = figma.createText();
  cardDesc.name = 'Card Description';
  cardDesc.characters = prompt.length > 80 ? prompt.substring(0, 80) + '...' : prompt;
  cardDesc.fontSize = 14;
  cardDesc.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  cardDesc.x = 20;
  cardDesc.y = 80;
  card.appendChild(cardDesc);
  elements.push(cardDesc);
  
  // Action buttons
  const primaryBtn = figma.createRectangle();
  primaryBtn.name = 'Primary Button';
  primaryBtn.resize(120, 36);
  primaryBtn.fills = [{ type: 'SOLID', color: primaryColor }];
  primaryBtn.x = 20;
  primaryBtn.y = 180;
  primaryBtn.cornerRadius = 8;
  card.appendChild(primaryBtn);
  elements.push(primaryBtn);
  
  const primaryBtnText = figma.createText();
  primaryBtnText.name = 'Primary Button Text';
  primaryBtnText.characters = 'Action';
  primaryBtnText.fontSize = 14;
  primaryBtnText.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  primaryBtnText.x = 50;
  primaryBtnText.y = 190;
  card.appendChild(primaryBtnText);
  elements.push(primaryBtnText);
  
  const secondaryBtn = figma.createRectangle();
  secondaryBtn.name = 'Secondary Button';
  secondaryBtn.resize(120, 36);
  secondaryBtn.fills = [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 } }];
  secondaryBtn.strokes = [{ type: 'SOLID', color: primaryColor }];
  secondaryBtn.strokeWeight = 1;
  secondaryBtn.x = 160;
  secondaryBtn.y = 180;
  secondaryBtn.cornerRadius = 8;
  card.appendChild(secondaryBtn);
  elements.push(secondaryBtn);
  
  const secondaryBtnText = figma.createText();
  secondaryBtnText.name = 'Secondary Button Text';
  secondaryBtnText.characters = 'Cancel';
  secondaryBtnText.fontSize = 14;
  secondaryBtnText.fills = [{ type: 'SOLID', color: primaryColor }];
  secondaryBtnText.x = 190;
  secondaryBtnText.y = 190;
  card.appendChild(secondaryBtnText);
  elements.push(secondaryBtnText);
  
  return elements;
}

// Generate wireframe design
async function generateWireframe(frame, prompt, brandGuidelines) {
  const elements = [];
  
  // Create wireframe boxes
  const boxes = [
    { name: 'Header', x: 0, y: 0, width: frame.width, height: 60 },
    { name: 'Sidebar', x: 0, y: 60, width: 200, height: frame.height - 60 },
    { name: 'Main Content', x: 200, y: 60, width: frame.width - 200, height: frame.height - 60 }
  ];
  
  for (const box of boxes) {
    const rect = figma.createRectangle();
    rect.name = box.name;
    rect.resize(box.width, box.height);
    rect.fills = [{ type: 'SOLID', color: { r: 0.9, g: 0.9, b: 0.9 } }];
    rect.strokes = [{ type: 'SOLID', color: { r: 0.5, g: 0.5, b: 0.5 } }];
    rect.strokeWeight = 2;
    rect.x = box.x;
    rect.y = box.y;
    frame.appendChild(rect);
    elements.push(rect);
    
    // Add label
    const label = figma.createText();
    label.name = `${box.name} Label`;
    label.characters = box.name;
    label.fontSize = 16;
    label.fills = [{ type: 'SOLID', color: { r: 0.3, g: 0.3, b: 0.3 } }];
    label.x = box.x + 10;
    label.y = box.y + 10;
    frame.appendChild(label);
    elements.push(label);
  }
  
  return elements;
}

// Generate generic design
async function generateGenericDesign(frame, prompt, brandGuidelines) {
  const elements = [];
  const brandColors = parseBrandGuidelines(brandGuidelines);
  const primaryColor = brandColors.primary || { r: 0.2, g: 0.4, b: 0.8 };
  
  // Create a simple layout based on the prompt
  const title = figma.createText();
  title.name = 'Title';
  title.characters = 'Generated Design';
  title.fontSize = 32;
  title.fills = [{ type: 'SOLID', color: { r: 0.1, g: 0.1, b: 0.1 } }];
  title.x = 50;
  title.y = 50;
  frame.appendChild(title);
  elements.push(title);
  
  const description = figma.createText();
  description.name = 'Description';
  description.characters = prompt || 'This design was generated by P2 Sim Design Generator.';
  description.fontSize = 16;
  description.fills = [{ type: 'SOLID', color: { r: 0.4, g: 0.4, b: 0.4 } }];
  description.x = 50;
  description.y = 100;
  frame.appendChild(description);
  elements.push(description);
  
  // Add a decorative element
  const decoration = figma.createEllipse();
  decoration.name = 'Decoration';
  decoration.resize(100, 100);
  decoration.fills = [{ type: 'SOLID', color: primaryColor }];
  decoration.x = frame.width - 150;
  decoration.y = 50;
  frame.appendChild(decoration);
  elements.push(decoration);
  
  return elements;
}

// =====================================================
// üì± Apply responsive layouts (placeholder)
// =====================================================
async function applyResponsiveDesign(frame, elements, breakpoints) {
  console.log('Applying responsive design:', breakpoints);
  breakpoints.forEach((bp, idx) => {
    const responsiveFrame = figma.createFrame();
    responsiveFrame.name = `${frame.name} - ${bp}`;
    responsiveFrame.resize(bp === 'mobile' ? 375 : bp === 'tablet' ? 768 : 1200, 800);
    responsiveFrame.x = (idx + 1) * 1300;
    responsiveFrame.fills = [{ type: 'SOLID', color: { r: 0.97, g: 0.97, b: 0.97 } }];
    figma.currentPage.appendChild(responsiveFrame);
  });
}

// =====================================================
// üßæ Export design (same logic, with better errors)
// =====================================================
async function handleExportDesign() {
  if (!pluginState.currentDesign) {
    figma.ui.postMessage({ type: 'export-error', data: { error: 'No design to export' } });
    figma.notify('‚ö†Ô∏è No design to export');
    return;
  }

  try {
    const { frame, metadata } = pluginState.currentDesign;
    const imageBytes = await frame.exportAsync({ format: 'PNG', constraint: { type: 'SCALE', value: 2 } });
    const base64 = figma.base64Encode(imageBytes);

    figma.ui.postMessage({
      type: 'export-completed',
      data: { success: true, imageData: base64, metadata }
    });

    figma.notify('üì¶ Export completed successfully!');
  } catch (error) {
    console.error('‚ùå Export error:', error);
    figma.notify('‚ùå Export failed: ' + error.message);
    figma.ui.postMessage({ type: 'export-error', data: { error: error.message } });
  }
}

// =====================================================
// üîÑ Load external design placeholder
// =====================================================
async function handleLoadDesign(data) {
  console.log('Loading design from external source:', data);
  figma.ui.postMessage({ type: 'design-loaded', data: { success: true } });
  figma.notify('üìÇ Loaded design successfully (mock)');
}

// =====================================================
// ‚úÖ Initialize complete
// =====================================================
figma.ui.postMessage({
  type: 'plugin-initialized',
  data: { version: '1.0.1', capabilities: ['generate-design', 'export-design', 'load-design'] }
});
figma.notify('‚úÖ P2 Sim Design Generator loaded');
